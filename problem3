#include <iostream>
#include <fstream>
#include <vector>
#include <omp.h>
#include <string>
#include <filesystem>

using namespace std;


bool isNotSorted(vector<int> nums);
vector<int>calculateFileSize(string filename, int threads)
{
    filesystem::path filePath = filename;
    long fileSize;
    int chunks = 0;
    vector<int> chunksAndFileSize;
    cout << "The number of available threads is " << threads << " threads " << endl;


    if(filesystem::exists(filePath))
    {
        fileSize = filesystem::file_size(filePath);
        chunks = fileSize/threads;
        cout << "The size of the file is: " << fileSize << " bytes " << endl;
        cout << "Each threads will compute " << chunks << " elements in each respective thread" << endl;
        
    }
    else
    {
        std::cout << "Problem finding File" << endl;
        
    }
    chunksAndFileSize.push_back(chunks);
    chunksAndFileSize.push_back(fileSize);

    return chunksAndFileSize;

}

string readFromFile(string fileName, int threads,vector<int>chunksAndFileSize){
    ifstream inputFile(fileName);
    vector<int> returned;
    string answer = "Sorted";
    
    int middle = chunksAndFileSize[0]/2;


    if(!inputFile.is_open()){
        cout << "Could not open file" << endl;
    }
    else
    {
        std::string line;
        //tasks that will handle the first half of the elements
        #pragma omp task shared(inputFile, middle, returned), firstprivate(line)
        {
            int ptr = 0;
            while(ptr < middle && getline(inputFile,line))
            {
                for(int i = ptr; i < ptr + chunksAndFileSize[0]; i++)
                {
                    returned.push_back(stoi(line));
                }
                if(isNotSorted(returned))
                {
                    answer = "Not Sorted";
                    break;
                }
                ptr += chunksAndFileSize[0];
            }
        }

        //tasks that will handle the last half of the elements
        #pragma omp task shared(inputFile, middle, returned), firstprivate(line)
        {
            int ptr = middle;
            while(ptr < chunksAndFileSize[1] && getline(inputFile,line))
            {
                for(int i = ptr; i < ptr + chunksAndFileSize[0]; i++)
                {
                    returned.push_back(stoi(line));
                }
                //if this function returns true then elements are not sorted
                if(isNotSorted(returned))
                {
                    answer = "Not Sorted";
                    break;
                }
                ptr += chunksAndFileSize[0];
            }
        }

        #pragma omp taskwait
        inputFile.close();
    }
    return answer;
}


bool isNotSorted(vector<int> nums)
{
    //assume that the list will be in descending order
    //means that elements will get smaller as you go further in the list.
    bool descending = true;
    if(nums.size() < 2){
        cerr << "error invalid input: ";

    }
    else{
        //elements are getting larger as you go further in the list so all other elements must follow suit.
        if (nums[0] < nums[1]){
            descending = false;
        }

        for(int i = 0; i < nums.size() - 1; i++){
            //qualities to make the list not sorted
            // if nums[i] < nums[i+1] and descending is true
            // if nums[i] > nums[i+1] and descending is false

            if((nums[i] < nums[i+1] && descending == true) || (nums[i] > nums[i+1] && descending == false)){
                return true;
            }
        }
    }
    return false;
}

int main()
{
    int threads = omp_get_max_threads();
    string result;

    //bytes of data in the file
    vector<int> data = calculateFileSize("prob3input.dat", threads);
    #pragma omp parallel
    {
        #pragma omp single
        {
           result = readFromFile("prob3input.dat", threads, data);
        }
    }

    cout << result << endl;
    
}


#include <iostream>
#include <fstream>
#include <vector>
#include <omp.h>
#include <string>
#include <filesystem>
#include <mutex>


using namespace std;


bool isNotSorted(vector<int> nums);
vector<streampos> offsets(string filename, int threads);
string readFromFile(string fileName, int threads,vector<int>chunksAndFileSize);





vector<streampos> offsets(string fileName, int threads)
{
    filesystem::path filePath = fileName;
    //stores the fileSize in bytes
    std::streampos fileSize;
    vector<streampos> offsets(threads + 1);

    if(filesystem::exists(filePath))
    {
        fileSize = filesystem::file_size(filePath);
        cout << "The size of the file is: " << fileSize << " bytes " << endl;
        
    }
    else
    {
        std::cout << "Problem finding File" << endl;
        
    }
    cout << fileSize / threads << "bytes is the amount each thread will compute" << endl;
    for(int i = 0; i < threads; i++){
        offsets[i] = fileSize * i / threads;
        cout << "Thread #" << i << " will start from " << offsets[i] << endl;
    }
    return offsets;

}

string readFromFile(string fileName, int threads,vector<streampos>offsets){
    
    
    string answer = "Sorted";
    mutex resultMutex;
    #pragma omp parallel
    {
        #pragma omp single
        {
            for(int i = 0; i < threads; i++)
            {
                #pragma omp task firstprivate(i)
                {
                    ifstream file(fileName);
                    file.seekg(offsets[i]);
                    
                    vector<int> numbers;
                    string line;
                    while(file.tellg() < offsets[i+1] && getline(file, line)){
                        if(!line.empty()){
                            numbers.push_back(stoi(line));
                        }
                    }

                    if(isNotSorted(numbers))
                    {
                        lock_guard<mutex> lock(resultMutex);
                        answer = "Not sorted";
                    }


                }
                
            }
            #pragma omp taskwait
            
        }
    }
    return answer;
}


bool isNotSorted(vector<int> nums)
{
    //assume that the list will be in descending order
    //means that elements will get smaller as you go further in the list.
        //elements are getting larger as you go further in the list so all other elements must follow suit.
        bool descending = nums[0] > nums[1];

        for(int i = 0; i < nums.size() - 1; i++){
            //qualities to make the list not sorted
            // if nums[i] < nums[i+1] and descending is true
            // if nums[i] > nums[i+1] and descending is false

            if((nums[i] < nums[i+1] && descending == true) || (nums[i] > nums[i+1] && descending == false)){
                return true;
            }
        }
    return false;
}

int main()
{
    int threads = omp_get_max_threads();
    

    //bytes of data in the file
    vector<streampos> offsetValues = offsets("prob3input.dat", threads);



    string result = readFromFile("prob3input.dat", threads, offsetValues);
    cout << (result) << endl;
}


    else
    {
        std::cout << "Problem finding File" << endl;
        
    }
    cout << fileSize / threads << "bytes is the amount each thread will compute" << endl;
    for(int i = 0; i < threads; i++){
        offsets[i] = fileSize * i / threads;
        cout << "Thread #" << i << " will start from " << offsets[i] << endl;
    }
    return offsets;

}

string readFromFile(string fileName, int threads,vector<streampos>offsets){
    
    
    string answer = "Sorted";
    mutex resultMutex;
    #pragma omp parallel
    {
        #pragma omp single
        {
            for(int i = 0; i < threads; i++)
            {
                #pragma omp task firstprivate(i)
                {
                    ifstream file(fileName);
                    file.seekg(offsets[i]);
                    
                    vector<int> numbers;
                    string line;
                    while(file.tellg() < offsets[i+1] && getline(file, line)){
                        if(!line.empty()){
                            numbers.push_back(stoi(line));
                        }
                    }

                    if(isNotSorted(numbers))
                    {
                        lock_guard<mutex> lock(resultMutex);
                        answer = "Not sorted";
                    }


                }
                
            }
            #pragma omp taskwait
            
        }
    }
    return answer;
}


bool isNotSorted(vector<int> nums)
{
    //assume that the list will be in descending order
    //means that elements will get smaller as you go further in the list.
        //elements are getting larger as you go further in the list so all other elements must follow suit.
        bool descending = nums[0] > nums[1];

        for(int i = 0; i < nums.size() - 1; i++){
            //qualities to make the list not sorted
            // if nums[i] < nums[i+1] and descending is true
            // if nums[i] > nums[i+1] and descending is false

            if((nums[i] < nums[i+1] && descending == true) || (nums[i] > nums[i+1] && descending == false)){
                return true;
            }
        }
    return false;
}

int main()
{
    int threads = omp_get_max_threads();
    

    //bytes of data in the file
    vector<streampos> offsetValues = offsets("prob3input.dat", threads);



    string result = readFromFile("prob3input.dat", threads, offsetValues);
    cout << (result) << endl;
}

